def cyk_algorithm(grammar, string):
    """
    Implements the CYK algorithm.

    Args:
        grammar: A dictionary where keys are non-terminal symbols, and values are lists of productions.
                 Each production is a tuple of terminal/non-terminal symbols in Chomsky Normal Form.
        string: The input string to check.

    Returns:
        bool: True if the string can be generated by the grammar, False otherwise.
    """
    n = len(string)
    if n == 0:
        return False

    # Initialize the table
    table = [[set() for _ in range(n)] for _ in range(n)]

    # Fill the diagonal with productions generating single terminals
    for i, terminal in enumerate(string):
        for lhs, rules in grammar.items():
            if (terminal,) in rules:
                table[i][i].add(lhs)

    # Fill the table for substrings of length > 1
    for length in range(2, n + 1):  # Length of the substring
        for i in range(n - length + 1):  # Start of the substring
            j = i + length - 1  # End of the substring
            for k in range(i, j):  # Split point
                for lhs, rules in grammar.items():
                    for rule in rules:
                        if len(rule) == 2:  # Binary production
                            B, C = rule
                            if B in table[i][k] and C in table[k + 1][j]:
                                table[i][j].add(lhs)

    # Check if the start symbol can derive the whole string
    start_symbol = 'S'
    return start_symbol in table[0][n - 1]


# Example Usage
if __name__ == "__main__":
    # Grammar in CNF
    grammar = {
        'S': [('A', 'B'), ('B', 'C')],
        'A': [('B','A'),('a')],
        'B': [('C','C'), ('b')],
        'C': [('A','B'), ('a')],
    }

    string = "baaba"
    result = cyk_algorithm(grammar, string)
    print(f"The string '{string}' is " + ("accepted" if result else "rejected") + " by the grammar.")

